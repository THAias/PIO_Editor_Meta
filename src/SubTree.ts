import _ from "lodash";

import { EntryType, PrimitiveDataTypes } from "./@types/Types";
import { isPrimitiveDataType } from "./Helper";

/**
 * Represents a small part of the whole PIO. This class allows the user to specify a path, and the SubTree object will
 * hold all PIO data found under that stated path. A SubTree object can be generated by the RootObject class. The user
 * can modify the SubTree data in the front end, and all changes can be integrated into the RootObject afterward.
 * @class
 */
export class SubTree {
    /**
     * The absolute path of the SubTree within the RootObject.
     * @type {string}
     */
    absolutePath: string;

    /**
     * The last element in the absolute path.
     * @type {string}
     */
    lastPathElement: string;

    /**
     * An array of added paths.
     * @type {string[]}
     */
    addedPaths: string[];

    /**
     * The data of the SubTree. It can be of PrimitiveDataTypes or undefined.
     * @type {PrimitiveDataTypes | undefined}
     */
    data?: PrimitiveDataTypes;

    /**
     * An array of child SubTree objects.
     * @type {SubTree[]}
     */
    children: SubTree[];

    /**
     * Constructs a SubTree object.
     * @param {string} path - The absolute path where the SubTree is located in the RootObject.
     * @param {EntryType | SubTree | undefined} pio - An EntryType or SubTree object.
     */
    constructor(path: string, pio: EntryType | SubTree | undefined) {
        if (!pio) {
            //Generate empty subTree
            this.absolutePath = path;
            this.lastPathElement = path.split(".").pop() as string;
            this.children = [] as SubTree[];
            this.addedPaths = [];
        } else if (pio instanceof SubTree) {
            //Generate SubTree out of a SubTree
            const temporarySubTree: SubTree = _.cloneDeep(pio.getSubTreeByPath(path));
            this.absolutePath = temporarySubTree.absolutePath;
            this.lastPathElement = temporarySubTree.lastPathElement;
            this.children = temporarySubTree.children;
            this.addedPaths = temporarySubTree.addedPaths;
        } else {
            //Generate a SubTree out of an EntryType object
            const pioData: EntryType | EntryType[] | undefined = _.cloneDeep(_.get(pio, path));
            this.absolutePath = path;
            this.lastPathElement = path.split(".").pop() as string;
            const temporarySubTree: SubTree | undefined = pioData
                ? this.transformEntryTypeToSubTree(pioData)
                : undefined;
            this.children = temporarySubTree ? temporarySubTree.children : ([] as SubTree[]);
            this.data = temporarySubTree ? temporarySubTree.data : undefined;
            this.addedPaths = [];
        }
    }

    /**
     * Checks whether the stated SubTree and all nested children hold at least one primitive data object.
     * @static
     * @param {SubTree} subTree - The method will search in this SubTree for primitive data objects
     * @returns {boolean} false, if passed SubTree and all nested children hold no primitive data
     */
    static doesSubTreeHoldData = (subTree: SubTree): boolean => {
        try {
            this.doesSubTreeHoldDataRecursive(subTree);
        } catch {
            return true;
        }
        return false;
    };

    /**
     * Private recursive function for checking whether a SubTree and all nested children hold at least one primitive
     * data object.
     * @private
     * @param {SubTree} subTree - The method will search in this SubTree for primitive data objects
     * @throws {Error} If the first nested SubTree is found, which holds primitive data
     */
    private static doesSubTreeHoldDataRecursive = (subTree: SubTree): void => {
        if (subTree.data) {
            throw Error("SubTree holds data");
        }

        subTree.children.forEach((child: SubTree): void => {
            this.doesSubTreeHoldDataRecursive(child);
        });
    };

    /**
     * Integrates a SubTree into 'this' SubTree. Either the subTree path is created or subTree with same path gets
     * overwritten.
     * @param {SubTree} subTree SubTree which should be integrated
     */
    integrateSubTree = (subTree: SubTree): void => {
        if (subTree.absolutePath.includes(this.absolutePath)) {
            const pathElementsToCreate: string[] = subTree.absolutePath
                .replace(this.absolutePath + ".", "")
                .split(".")
                .slice(0, -1);
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            let currentSubTree: SubTree = this;
            pathElementsToCreate.forEach((element: string) => {
                try {
                    currentSubTree = currentSubTree.getChild(element);
                } catch {
                    //Child does not exist and must be created
                    const newSubTree: SubTree = new SubTree(`${currentSubTree.absolutePath}.${element}`, undefined);
                    currentSubTree.children.push(newSubTree);
                    currentSubTree = newSubTree;
                }
            });

            //Remove subTree, if child with same path exists
            try {
                currentSubTree.getChild(subTree.lastPathElement);
                currentSubTree.deleteSubTreeByPath(subTree.lastPathElement);
            } catch {}

            //Integrate subTree
            currentSubTree.children.push(subTree);
        }
    };

    /**
     * Returns the subTree stored under the stated relative subTreePath. If subTreePath does not exist, an empty SubTree
     * pointing to the subTreePath is returned. All paths in the 'addedPaths[]' array are transferred correctly to the
     * new SubTree.
     * @param {string} subTreePath - The relative subTree path
     * @returns {SubTree} another SubTree stored under the relative path
     */
    getSubTreeByPath = (subTreePath: string): SubTree => {
        //Handle empty 'subTreePath'
        if (subTreePath === "") {
            return this;
        }

        //Handle non-empty 'subTreePath'
        const splittedPath: string[] = subTreePath.split(".");

        //Get data by iterating through the relative subTreePath
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let subTree: SubTree | undefined = this;
        let parentSubTree: SubTree | undefined = undefined;
        splittedPath.forEach((pathElement: string) => {
            if (subTree) {
                parentSubTree = subTree;
                try {
                    subTree = subTree.getChild(pathElement);
                } catch {
                    subTree = undefined;
                }
            } else {
                parentSubTree = undefined;
            }
        });

        //If 'subTreePath' does not exist, check whether last subTreePath element points to an array
        //If yes, generate a subTree container holding all array items (e.g. "address[1]", "address[2], ...)
        if (!subTree && parentSubTree) {
            const lastSubTreePathElement: string = splittedPath[splittedPath.length - 1];
            const allAppropriateSubTrees: SubTree[] = (parentSubTree as SubTree).children.filter((child: SubTree) => {
                return child.lastPathElement.split("[")[0] === lastSubTreePathElement;
            });
            if (allAppropriateSubTrees.length > 0) {
                subTree = new SubTree(this.absolutePath + "." + subTreePath, undefined);
                subTree.children = allAppropriateSubTrees;
            }
        }

        //Generate return value (SubTree)
        if (subTree) {
            //If subTree exists, return appropriate SubTree and copy all relevant 'addedPaths' to the new SubTree
            subTree.addedPaths = this.addedPaths.filter((path: string) => {
                return path.includes(this.absolutePath + "." + subTreePath);
            });
            return subTree;
        } else {
            return new SubTree(this.absolutePath + "." + subTreePath, undefined);
        }
    };

    /**
     * Returns the primitive data which may be stored under 'data'. This method can be chained with
     * 'getSubTreeByPath()'.
     * @returns {PrimitiveDataTypes | undefined} The 'data' property of the SubTree.
     */
    getValue = (): PrimitiveDataTypes | undefined => {
        return this.data;
    };

    /**
     * Returns primitive data as a string, if no data is present, returns 'undefined'.
     * @returns {string | undefined} The string representation of the primitive data, or 'undefined' if no data is present.
     */
    getValueAsString = (): string | undefined => {
        if (this.data) {
            return this.data.toString();
        } else {
            return undefined;
        }
    };

    /**
     * Adds primitive data to the SubTree by using the stated 'subTreePath'. If subTreePath does not exist, new SubTrees
     * are generated.
     * @param {string} subTreePath - Relative path where primitive data should be added.
     * @param {PrimitiveDataTypes | undefined} data - Primitive data which should be added.
     */
    setValue = (subTreePath: string, data: PrimitiveDataTypes | undefined): void => {
        /**
         * Local function: Iterates through path elements and generates new SubTrees if necessary.
         * The last SubTree will be returned.
         * @param {string} subTreePath - The relative path to iterate through.
         * @returns {SubTree} The last SubTree in the path.
         */
        const createSubTreePath = (subTreePath: string): SubTree => {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            let subTree: SubTree = this;

            subTreePath.split(".").forEach((pathElement: string, index: number): void => {
                try {
                    subTree = subTree.getChild(pathElement);
                } catch {
                    let newSubTree: SubTree;

                    //Different handling for subTree container which are just holding children of the same type
                    //(e.g. name[0], name[1], etc.)
                    if (
                        index === 0 &&
                        pathElement.includes("[") &&
                        subTree.lastPathElement === pathElement.split("[")[0]
                    ) {
                        newSubTree = new SubTree(subTree.absolutePath + "[" + pathElement.split("[")[1], undefined);
                    } else {
                        newSubTree = new SubTree(subTree.absolutePath + "." + pathElement, undefined);
                    }

                    subTree.children.push(newSubTree);
                    subTree = newSubTree;
                }
            });

            return subTree;
        };

        if (data) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            let lastSubTree: SubTree = this;

            if (subTreePath.length > 0) {
                lastSubTree = createSubTreePath(subTreePath);
            }

            //Attach primitive or complex data to the last SubTree and store path under property 'addedPaths'
            lastSubTree.data = data;
            this.addSubTreePathTo_addedPaths(subTreePath);
        }
    };

    /**
     * Deletes the 'data' property of the SubTree which can be found under the stated 'subTreePath'.
     * @param {string} subTreePath - Relative path to the SubTree where 'data' property should be deleted
     */
    deleteValue = (subTreePath: string): void => {
        //Validate existence of subTreePath
        if (this.validateSubTreePath(subTreePath)) {
            //Handle empty 'subTreePath'
            if (subTreePath === "") {
                this.data = undefined;
            } else {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                let subTree: SubTree = this;
                const splittedPath: string[] = subTreePath.split(".");
                splittedPath.forEach((pathElement: string): void => {
                    subTree = subTree.getChild(pathElement);
                });
                subTree.data = undefined;
            }
        }
    };

    /**
     * Deletes a whole SubTree stored under the 'subTreePath'.
     * @param {string} subTreePath Relative path to the SubTree which should be deleted
     */
    deleteSubTreeByPath = (subTreePath: string): void => {
        //Validate existence of subTreePath (if path does not exist, do nothing)
        if (this.validateSubTreePath(subTreePath)) {
            //Delete all data stored under the stated path
            const subTree: SubTree = this.getSubTreeByPath(subTreePath);
            subTree.data = undefined;
            subTree.children = [] as SubTree[];

            //Get the parent SubTree
            const parentSubTree: SubTree = this.getSubTreeByPath(subTreePath.split(".").slice(0, -1).join("."));
            const lastPathElement: string = subTreePath.split(".").pop() as string;
            const indexOfSubTreeInParentSubTree: number = parentSubTree.children.findIndex(
                (child: SubTree): boolean => {
                    return child.lastPathElement === lastPathElement;
                }
            );

            //Delete SubTree from ParentSubTree
            const firstPart: SubTree[] = parentSubTree.children.slice(0, indexOfSubTreeInParentSubTree);
            const secondPart: SubTree[] | undefined =
                indexOfSubTreeInParentSubTree === parentSubTree.children.length - 1
                    ? undefined
                    : parentSubTree.children.slice(indexOfSubTreeInParentSubTree + 1);
            parentSubTree.children = secondPart ? [...firstPart, ...secondPart] : firstPart;
        }
    };

    /**
     * Transform the SubTree to an EntryType. This method must be called before integrating the SubTree into the
     * RootObject in the Backend. During conversation all SubTrees which hold no data are removed.
     * @returns {EntryType | EntryType[]} An EntryType or EntryType[] generated out of the SubTree
     */
    transformSubTreeToEntryType = (): EntryType | EntryType[] => {
        //SubTree points to an array, if all children has the same indexed name like their parentSubTree
        //e.g. this.lastPathElement = "name" -> all children have the same indexed 'lastPathElement' ("name[0], name[1])
        let pointsToArray = false;
        this.getAllChildren().forEach((childName: string): void => {
            pointsToArray = this.lastPathElement === childName.split("[")[0];
        });

        //Initialize entryType
        const entryType: EntryType = {} as EntryType;

        if (pointsToArray) {
            //Dissolve array
            this.children.forEach((child: SubTree): void => {
                this.transformSubTreeToEntryTypeRecursive(child, "", entryType);
            });
            return entryType[this.lastPathElement];
        } else {
            //Start recursive call
            this.transformSubTreeToEntryTypeRecursive(this, "", entryType);

            //Get the right return value
            if (this.lastPathElement.includes("[")) {
                //Handle array
                const rootKey: string = this.lastPathElement.split("[")[0];
                const arrayIndex: number = Number(this.lastPathElement.split("[")[1].slice(0, -1));
                return entryType[rootKey.toString()][Number(arrayIndex)];
            } else {
                //No array handling
                const rootKey: string = this.lastPathElement;
                return entryType[rootKey.toString()];
            }
        }
    };

    /**
     * Returns the child SubTree described by the argument 'pathElement'.
     * @param {string} pathElement - This argument is compared with the 'lastPathElement' property of all SubTree children
     * @returns {boolean} a specific SubTree child described by the argument 'pathElement', otherwise undefined
     * @description If no child is found, an Error is thrown
     */
    getChild = (pathElement: string): SubTree => {
        const child: SubTree | undefined = this.children.find((arrayItem: SubTree): boolean => {
            return arrayItem.lastPathElement === pathElement;
        });
        if (child) {
            return child;
        } else {
            throw Error("No child found");
        }
    };

    /**
     * Returns all children of the SubTree object.
     * @returns {string[]} an array of strings which contains the lastPathElement of all children SubTrees
     */
    getAllChildren = (): string[] => {
        const returnArray: string[] = [] as string[];
        this.children.forEach((child: SubTree): void => {
            returnArray.push(child.lastPathElement);
        });
        return returnArray;
    };

    /**
     * Private method to transform an EntryType to a tree structure of SubTrees. Used in the constructor.
     * @private
     * @param {EntryType | EntryType[]} entryType - EntryType object which should be transformed to s SubTree
     * @returns {SubTree} the newly generated SubTree
     */
    private transformEntryTypeToSubTree = (entryType: EntryType | EntryType[]): SubTree => {
        const subTree: SubTree = new SubTree(this.absolutePath, undefined);

        if (
            Object.keys(entryType).length === 1 &&
            (Object.keys(entryType)[0] === "__value" || Object.keys(entryType)[0] === "__url")
        ) {
            //EntryType holds just one single primitive data type stored under '__value' or '__url' -> no recursive call needed
            subTree.data = entryType[Object.keys(entryType)[0]];
        } else if (isPrimitiveDataType(entryType)) {
            //EntryType holds just one single primitive data type -> no recursive call needed
            subTree.data = entryType as PrimitiveDataTypes;
        } else {
            //SubTree holds more data -> recursive call
            this.transformEntryTypeToSubTreeRecursive(entryType, subTree);
        }

        return subTree;
    };

    /**
     * Recursive function for transforming an EntryType to a SubTree.
     * @private
     * @param {EntryType | EntryType[]} entryType - EntryType object which should be transformed to a SubTree
     * @param {SubTree} subTree - A reference to a SubTree object which will become the transformed EntryType
     */
    private transformEntryTypeToSubTreeRecursive = (entryType: EntryType | EntryType[], subTree: SubTree): void => {
        if (entryType instanceof Array) {
            //Resolve input array (EntryType[]) by doing recursive calls for every array item
            entryType.forEach((item: EntryType, index: number): void => {
                const newPath: string = subTree.absolutePath + "[" + index + "]";
                const newSubTree: SubTree = new SubTree(newPath, undefined);
                subTree.children.push(newSubTree);
                this.transformEntryTypeToSubTreeRecursive(item, newSubTree);
            });
        } else {
            //Transform EntryType object to SubTrees by iterating through all keys of the EntryType object
            Object.keys(entryType).forEach((key: string): void => {
                if (key === "__value" || key === "__url") {
                    //Recursive call reached a primitive data type -> End recursive call
                    subTree.data = entryType[key.toString()] as PrimitiveDataTypes;
                } else if (key === "@id@" || key === "@profile@" || key === "@div@" || key === "@status@") {
                    //Recursive call reached header data -> End recursive call
                    const headerPath: string = subTree.absolutePath + "." + key;
                    const subTreeForHeader: SubTree = new SubTree(headerPath, undefined);
                    subTreeForHeader.data = entryType[key.toString()] as PrimitiveDataTypes;
                    subTree.children.push(subTreeForHeader);
                } else {
                    const valueOfKey: EntryType | EntryType[] | PrimitiveDataTypes = entryType[key.toString()];
                    if (valueOfKey instanceof Array) {
                        //Do recursive call for all array items stored under a key
                        valueOfKey.forEach((item: EntryType, index: number): void => {
                            const newPath: string = subTree.absolutePath + "." + key + "[" + index + "]";
                            const newSubTree: SubTree = new SubTree(newPath, undefined);
                            subTree.children.push(newSubTree);
                            this.transformEntryTypeToSubTreeRecursive(item, newSubTree);
                        });
                    } else {
                        //Do recursive call for the object stored under a key
                        const newSubTree: SubTree = new SubTree(subTree.absolutePath + "." + key, undefined);
                        subTree.children.push(newSubTree);
                        this.transformEntryTypeToSubTreeRecursive(entryType[key.toString()], newSubTree);
                    }
                }
            });
        }
    };

    /**
     * Validates whether a subTreePath exists in the current SubTree object.
     * @private
     * @param {string} path - Path for validation
     * @returns {boolean} false, if path does not exist in SubTree
     */
    private validateSubTreePath = (path: string): boolean => {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let currentSubTree: SubTree = this;
        try {
            if (path === "") {
                return true;
            }
            path.split(".").forEach((pathElement: string): void => {
                currentSubTree = currentSubTree.getChild(pathElement);
            });
            return true;
        } catch {
            return false;
        }
    };

    /**
     * Private recursive function for converting the SubTree to an EntryType.
     * @private
     * @param {SubTree} subTree - Current SubTree for the recursive call
     * @param {string} currentSubTreePath - Current relative subTreePath for the recursive call
     * @param {EntryType} entryType - Reference to an EntryType which will become the transformed SubTree
     */
    private transformSubTreeToEntryTypeRecursive = (
        subTree: SubTree,
        currentSubTreePath: string,
        entryType: EntryType
    ): void => {
        //If current subTree does not hold any data, no further recursive call is needed
        if (SubTree.doesSubTreeHoldData(subTree)) {
            if (subTree.data) {
                this.addDataToEntryType(currentSubTreePath, subTree, entryType);
            }

            //Get new subTree path
            const newSubTreePath: string =
                currentSubTreePath === ""
                    ? subTree.lastPathElement
                    : currentSubTreePath + "." + subTree.lastPathElement;

            //Recursive call
            subTree.children.forEach((child: SubTree): void => {
                this.transformSubTreeToEntryTypeRecursive(child, newSubTreePath, entryType);
            });
        }
    };

    /**
     * Adds primitive data to the passed 'entryType' by differentiate between extensions, header data and normal values.
     * This function is used in the 'transformSubTreeToEntryTypeRecursive' method.
     * @private
     * @param {string} currentSubTreePath - Current relative subTreePath for the recursive call
     * @param {SubTree} subTree - Current SubTree for the recursive call
     * @param {EntryType} entryType - Reference to an EntryType which will become the transformed SubTree
     * @description This function adds data to the entryType by directly changing the passed entryType object
     */
    private addDataToEntryType = (currentSubTreePath: string, subTree: SubTree, entryType: EntryType): void => {
        if (subTree.lastPathElement.includes("extension")) {
            //Handle extensions
            const pathForWritingData: string =
                currentSubTreePath === ""
                    ? subTree.lastPathElement + ".__url"
                    : currentSubTreePath + "." + subTree.lastPathElement + ".__url";
            _.set(entryType, pathForWritingData, subTree.data);
        } else if (
            subTree.lastPathElement === "@id@" ||
            subTree.lastPathElement === "@profile@" ||
            subTree.lastPathElement === "@status@" ||
            subTree.lastPathElement === "@div@"
        ) {
            //Handle header data
            const pathForWritingData: string =
                currentSubTreePath === ""
                    ? subTree.lastPathElement
                    : currentSubTreePath + "." + subTree.lastPathElement;
            _.set(entryType, pathForWritingData, subTree.data);
        } else {
            //Handle normal values
            const pathForWritingData: string =
                currentSubTreePath === ""
                    ? subTree.lastPathElement + ".__value"
                    : currentSubTreePath + "." + subTree.lastPathElement + ".__value";
            _.set(entryType, pathForWritingData, subTree.data);
        }
    };

    /**
     * Adds a subTreePAth to the class property 'addedPaths' and handles duplicates.
     * @private
     * @param {string} subTreePath - subTreePath which should be added
     */
    private addSubTreePathTo_addedPaths = (subTreePath: string): void => {
        let pathForAdding: string;

        if (subTreePath === "") {
            pathForAdding = this.absolutePath;
        } else if (
            this.lastPathElement === subTreePath.split(".")[0].split("[")[0] &&
            subTreePath.split(".")[0].includes("[")
        ) {
            pathForAdding = this.absolutePath.split(".").slice(0, -1).join(".") + "." + subTreePath;
        } else {
            pathForAdding = this.absolutePath + "." + subTreePath;
        }

        if (!this.addedPaths.includes(pathForAdding)) {
            this.addedPaths.push(pathForAdding);
        }
    };
}
